---
layout: post
title: ADO.NET Performance Test&#58; Getting a Single Value
date: 2008-02-01 18:49
author: John
comments: true
categories: [All]
---
<P>I ran some tests using ADO.NET to measure the time it takes to retrieve a single value from a database. All of my tests had the following attributes:</P> <UL> <LI>Each test gets the CompanyName for the specified CustomerID (in Northwind) <LI>The same connection string, using integrated security <LI>Stored procedure (vs inline SQL) <LI>I used a SqlCommand with a parameter for the input value (and the output, for the output parameter test) <LI>I ran the stored procedures ahead of time to remove the possibility of the first time performance hit <LI>SqlConnection, SqlCommand and the SqlDataAdatper (where applicable) all used the <A href="/blogs/john.papa/archive/2005/04/01/60984.aspx">using statement</A> <LI>I added the result to a list box in each test, just to show that we did something with the value <LI>I ran the complete tests over 25,000 iterations, including destruction of all ADO.NET objects (and instantiation) </LI></UL> <P>The techniques that I tested were:</P> <UL> <LI>ExecuteScalar&nbsp; <UL> <LI>Retrieving the CompanyName from a stored procedure as the return value of the ExecuteScalar method</LI></UL> <LI>Output Parameters <UL> <LI>Retrieving the CompanyName from an output parameter of a stored procedure </LI></UL> <LI>DataSet <UL> <LI>Retrieving the CompanyName from the first row amd colun of a DataSet, as the result of a stored procedure </LI></UL></LI></UL> <P>Here were the test results:</P><IMG alt="" src="/photos/jpapa/images/61747/original.aspx" border=0> <P>So it turns out that ExecuteScalar test ran slightly faster than the output parameter test, and much faster than the DataSet test. In case the image comes ut fuzzy, here are the results again:</P> <TABLE id=Table1 cellSpacing=2 cellPadding=2 align=center border=1> <TBODY> <TR> <TH noWrap>Test</TH> <TH noWrap>Iteration</TH> <TH noWrap>Elapsed ms</HD></TR> <TR> <TD noWrap>ExecuteScalar</TD> <TD noWrap align=middle>1</TD> <TD noWrap align=right>6577</TD></TR> <TR> <TD noWrap>ExecuteScalar</TD> <TD noWrap align=middle>2</TD> <TD noWrap align=right>6468</TD></TR> <TR> <TD noWrap>ExecuteScalar</TD> <TD noWrap align=middle>3</TD> <TD noWrap align=right>6577</TD></TR> <TR> <TD noWrap>Output Parameter</TD> <TD noWrap align=middle>1</TD> <TD noWrap align=right>6780</TD></TR> <TR> <TD noWrap>Output Parameter</TD> <TD noWrap align=middle>2</TD> <TD noWrap align=right>6671</TD></TR> <TR> <TD noWrap>Output Parameter</TD> <TD noWrap align=middle>3</TD> <TD noWrap align=right>6749</TD></TR> <TR> <TD noWrap>DataSet</TD> <TD noWrap align=middle>1</TD> <TD noWrap align=right>10655</TD></TR> <TR> <TD noWrap>DataSet</TD> <TD noWrap align=middle>2</TD> <TD noWrap align=right>10608</TD></TR> <TR> <TD noWrap>DataSet</TD> <TD noWrap align=middle>3</TD> <TD noWrap align=right>10608</TD></TR></TBODY></TABLE> <P>Given that ExecuteScalar is easier to implement that an output parameter, I'd choose that over output parameters. But it is interesting that ExecuteScalar and using output parameters are so close. I found it very interesting to see how slow the DataSet technique was. Kind of figured that it would be slower, but that was somewhat surprising (the DataSet is onyl returning a single row and column).</P> <P>In case you are wondering, I ran the tests again over iterations of </P> <UL> <LI>1000 <LI>10,000 <LI>100,000 <LI>250,000</LI></UL> <P>The results were very similar in each case. When I ran the tests for less than 1000, sometimes it ran so quick that the results were 0 ms. Not much help there ;-)</P> <P>Anyway, I thought it was interesting to see the results of how well or porrly these 3 methods performed. You might wonder why I did not try the DataReader ... well, I'll try that one and re-post later. </P> <FIELDSET style="LEFT: 10px; TOP: 1320px"><LEGEND>The ExecuteScalar Test</LEGEND><PRE><SPAN style="FONT-SIZE: 9pt; COLOR: black; FONT-FAMILY: Arial"><SPAN style="COLOR: blue">case</SPAN> "ExecuteScalar" : dteTimer = DateTime.Now; <SPAN style="COLOR: blue">for</SPAN> (<SPAN style="COLOR: blue">int</SPAN> i = 1; i &lt;= iLimit; i++) { <SPAN style="COLOR: blue">using</SPAN> (SqlConnection cn = <SPAN style="COLOR: blue">new</SPAN> SqlConnection(sCn)) { <SPAN style="COLOR: blue">string</SPAN> proc = "prGetCustomerName"; cn.Open(); <SPAN style="COLOR: blue">using</SPAN> (SqlCommand cmd = <SPAN style="COLOR: blue">new</SPAN> SqlCommand(proc, cn)) { cmd.CommandType = CommandType.StoredProcedure; SqlParameter parmCustID = <SPAN style="COLOR: blue">new</SPAN> SqlParameter("@CustomerID", SqlDbType.NVarChar, 10); parmCustID.Direction = ParameterDirection.Input; parmCustID.Value = "FRANK"; cmd.Parameters.Add(parmCustID); sCompany = cmd.ExecuteScalar().ToString(); lstResults.Items.Add(i.ToString() + ") " + sCompany); } cn.Close(); } } dblPeriod = TimeSpan.FromTicks(DateTime.Now.Ticks - dteTimer.Ticks).TotalMilliseconds; lstElapsedTime.Items.Add("ExecuteScalar: " + dblPeriod.ToString() + " ms"); <SPAN style="COLOR: blue">break</SPAN>;</SPAN></PRE></FIELDSET>

