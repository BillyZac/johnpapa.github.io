---
layout: post
title: Binding Children Rows to a DataGrid with ADO.NET DataRelations
date: 2008-02-01 18:49
author: John
comments: true
categories: [All]
---
<P>Over the past few days I've had a few questions regarding a situation where there is a list of parent rows (let's say Orders) loaded into a dropdown list and a list of child rows (let's say Order Details) loaded into a grid. The idea being that when the user selects the Order from the dropdown list, the Order Details grid loads that Order's Order Details records without querying the database again. The DataSet contains all of&nbsp;the Orders and their Order Details rows&nbsp;and they are related by a DataRelation. In this situation you only want the Order Details for the selected Order to be bound to the DataGrid. (In this sample I wil focus on how to do this using the <B>DataRowView.CreateChildView</B> method.) Here is what the web page will look like:</P> <P><IMG alt="" src="/photos/jpapa/images/61700/original.aspx" border="0"></P> <P>So let's review the situation before going any further:</P> <OL> <LI> A single DataSet stores all Orders for a specific customer and all of those Orders' Order Details <LI> The DataSet contains a DataRelation that relates the parent/child DataTables (Orders/Order Details) <LI> The DataSet is read-only, for viewing purposes only. <LI> The DataSet needs to be cached somewhere. <LI> The data is not volatile <LI> When an order is selected, only its Order Details should be displayed in the DataGrid</LI></OL> <P>First, to load the DataSet there is a method called RefreshDataSetFromDB. This hits the database, grabs the Orders and&nbsp;the Order Details, throws them into 2 DataTable objects within the same DataSet and relates them via a DataRelation.</P> <FIELDSET> <LEGEND>Get the 2 Tables from the DB</LEGEND> <SPAN style="COLOR: black;font-size: 9pt;font-family:Arial;"><SPAN style="COLOR: blue;">private</SPAN> DataSet RefreshDataSetFromDB() <BR>{ <BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN style="COLOR: blue">string</SPAN> sCn = "server=(local);database=northwind;integrated security=true;"; <BR>&nbsp;&nbsp;&nbsp;&nbsp;DataSet ds = <SPAN>new</SPAN> DataSet(); <BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN style="COLOR: blue">using</SPAN> (SqlConnection cn = <SPAN style="COLOR: blue">new</SPAN> SqlConnection(sCn)) <BR>&nbsp;&nbsp;&nbsp;&nbsp;{ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cn.Open(); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN style="COLOR: blue">string</SPAN> sqlOrders = "SELECT OrderID FROM ORDERS WHERE CustomerID = 'ALFKI'"; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN style="COLOR: blue">using</SPAN> (SqlCommand cmd = <SPAN style="COLOR: blue">new</SPAN> SqlCommand(sqlOrders, cn)) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN style="COLOR: blue">using</SPAN> (SqlDataAdapter da = <SPAN style="COLOR: blue">new</SPAN> SqlDataAdapter(cmd)) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;da.Fill(ds, "Orders"); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuilder sb = <SPAN style="COLOR: blue">new</SPAN> StringBuilder(""); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sb.Append("SELECT od.OrderID, p.ProductID, p.ProductName, od.UnitPrice, od.Quantity");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sb.Append(" FROM [Order Details] od INNER JOIN Products p ON od.ProductID = p.ProductID"); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sb.Append(" WHERE OrderID IN ("); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sb.Append(" SELECT OrderID FROM Orders WHERE CustomerID = 'ALFKI')"); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN style="COLOR: blue">string</SPAN> sqlOrderDetails = sb.ToString(); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN style="COLOR: blue">using</SPAN> (SqlCommand cmd = <SPAN style="COLOR: blue">new</SPAN> SqlCommand(sqlOrderDetails, cn)) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN style="COLOR: blue">using</SPAN> (SqlDataAdapter da = <SPAN style="COLOR: blue">new</SPAN> SqlDataAdapter(cmd)) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;da.Fill(ds, "Order Details"); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds.Relations.Add("OrdersToOrderDetails", <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds.Tables["Orders"].Columns["OrderID"], <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds.Tables["Order Details"].Columns["OrderID"]); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cn.Close(); <BR>&nbsp;&nbsp;&nbsp;&nbsp;} <BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN style="COLOR: blue">return</SPAN> ds; <BR>} <BR></SPAN> </FIELDSET> <P>Normally I'd be using stored procedures here, but for simplicity sake of this code sample I used inline SQL. I also would not hard code the CustomerID, instead I would use a parameter passed in from somewhere (a post from another form, a control on this page, outer space, who knows). Since I built my inline SQL statement, notice the use of the StringBuilder class to build the SQL statement for the Order Details. Once I have to concatenate 3 lines or more, I use the StringBuilder. If I concatenate string objects together instead, the fact that strings are immutable means that I keep creating and throwing the value away. What's my point: StringBuilder good. Concat bad. </P> <P>I used the <A href="/blogs/john.papa/archive/2005/04/01/60984.aspx">using</A> statement quite a bit in the RefreshDataSetFromDB method. The <A href="/blogs/john.papa/archive/2005/04/01/60984.aspx"> using</A> statement will clean up my resources when its block ends. Quite a nice feature in my opinion. And while I am at it, I would not hard code my connection string. Instead I would store it in a custom config file or the web.config. </P> <P>Alright, that's relatively basic ADO.NET. To load the page I use the following code which grabs a DataSet. On the first call to the page I also load the Order rows into the dropdown list.</P> <FIELDSET> <LEGEND>Page_Load</LEGEND> <SPAN style="COLOR: black;font-size: 9pt;font-family:Arial;"><BR><SPAN style="COLOR: blue">private</SPAN> <SPAN style="COLOR: blue">void</SPAN> Page_Load(object sender, System.EventArgs e) <BR>{ <BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN style="COLOR: green">// Get the DataSet</SPAN> <BR>&nbsp;&nbsp;&nbsp;&nbsp;DataSet ds = GetDataSetFromCache(); <BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN style="COLOR: blue">if</SPAN> (!IsPostBack) <BR>&nbsp;&nbsp;&nbsp;&nbsp;{ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LoadOrdersList(ds); <BR>&nbsp;&nbsp;&nbsp;&nbsp;} <BR>} </SPAN> </FIELDSET> <P><BR> When I call GetDataSetFromCache, it the DataSet is not in Cache, then I go get the data from the database using the RefreshDataSetFromDB method. Then I stick the DataSet in the Cache. <BR> </P> <FIELDSET> <LEGEND>GetDataSetFromCache </LEGEND> <SPAN style="COLOR: black;font-size: 9pt;font-family:Arial;"><BR><SPAN style="COLOR: blue">private</SPAN> DataSet GetDataSetFromCache() <BR>{ <BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN style="COLOR: green">// test // Cache.Remove("MyCachedDataSet");</SPAN> <BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN style="COLOR: green">// Get the DataSet from Cache</SPAN> <BR>&nbsp;&nbsp;&nbsp;&nbsp;DataSet ds = (DataSet)Cache.Get("MyCachedDataSet"); <BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN style="COLOR: blue">if</SPAN> (ds == <SPAN style="COLOR: blue">null</SPAN>) <BR>&nbsp;&nbsp;&nbsp;&nbsp;{ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN style="COLOR: green">// Get the DataSet and load it into Cache</SPAN> <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds = RefreshDataSetFromDB(); <BR>&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;CacheDataSet(ds); <BR>&nbsp;&nbsp;&nbsp;&nbsp;} <BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN style="COLOR: blue">return</SPAN> ds; <BR>} <BR></SPAN> </FIELDSET> <P><BR> I cache the DataSet using the Cache.Insert method. Here, I am creating a key called MyCachedDataSet so I can grab the DataSet back out of Cache using this key. SInce the data does not change often, I am telling the Cache to store this data for 1 hour from now. You can play with this setting or the sliding expiration argument to get your desired effect. The final parameter tells the Cache what method to call when the DataSet is removed from the Cache. Here, I tell it to call the CacheCallback handler. <BR> </P> <FIELDSET> <LEGEND>CacheDataSet</LEGEND> <SPAN style="COLOR: black;font-size: 9pt;font-family:Arial;"><BR><SPAN style="COLOR: blue">private</SPAN> <SPAN style="COLOR: blue">void</SPAN> CacheDataSet(DataSet ds) <BR>{ <BR>&nbsp;&nbsp;&nbsp;&nbsp;Cache.Insert("MyCachedDataSet", ds, <SPAN style="COLOR: blue">null</SPAN>, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DateTime.Now.AddHours(1), Cache.NoSlidingExpiration, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CacheItemPriority.Normal, <SPAN style="COLOR: blue">new</SPAN> CacheItemRemovedCallback(CacheCallback)); <BR>} <BR></SPAN> </FIELDSET> <P><BR> The CacheCallBack handler will reload the data from the database, throw the DataSet back in Cache and the load the Orders dropdown list once again. </P> <FIELDSET> <LEGEND>CacheCallback</LEGEND> <SPAN style="COLOR: black;font-size: 9pt;font-family:Arial;"><BR><SPAN style="COLOR: blue">private</SPAN> <SPAN style="COLOR: blue">void</SPAN> CacheCallback(<SPAN style="COLOR: blue">string</SPAN> str, <SPAN style="COLOR: blue">object</SPAN> obj, CacheItemRemovedReason reason) <BR>{ <BR>&nbsp;&nbsp;&nbsp;&nbsp;DataSet ds = RefreshDataSetFromDB(); <BR>&nbsp;&nbsp;&nbsp;&nbsp;CacheDataSet(ds); <BR>&nbsp;&nbsp;&nbsp;&nbsp;LoadOrdersList(ds); <BR>} <BR></SPAN> </FIELDSET> <P><BR> Here is how the Orders dropdown list is loaded (using data binding). </P> <FIELDSET> <LEGEND>LoadOrdersList</LEGEND> <SPAN style="COLOR: black;font-size: 9pt;font-family:Arial;"><BR><SPAN style="COLOR: blue">private</SPAN> <SPAN style="COLOR: blue">void</SPAN> LoadOrdersList(DataSet ds) <BR>{ <BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN style="COLOR: green">// Load the Orders</SPAN> <BR>&nbsp;&nbsp;&nbsp;&nbsp;DataView dv = <SPAN style="COLOR: blue">new</SPAN> DataView(ds.Tables["Orders"]); <BR>&nbsp;&nbsp;&nbsp;&nbsp;ddlOrders.DataSource = dv; <BR>&nbsp;&nbsp;&nbsp;&nbsp;ddlOrders.DataTextField = "OrderID"; <BR>&nbsp;&nbsp;&nbsp;&nbsp;ddlOrders.DataValueField = "OrderID"; <BR>&nbsp;&nbsp;&nbsp;&nbsp;ddlOrders.DataBind(); <BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN style="COLOR: green">// Clear the Order Details grid</SPAN> <BR>&nbsp;&nbsp;&nbsp;&nbsp;dgOrderDetails.DataSource = <SPAN style="COLOR: blue">null</SPAN>; <BR>&nbsp;&nbsp;&nbsp;&nbsp;dgOrderDetails.DataBind(); <BR>} <BR></SPAN> </FIELDSET> <P><BR> When the Reload button is clicked, the DataSet is removed from cache and then reloaded from the database. Then the DataSet is stored in Cache and the Orders dropdown list is reloaded. </P> <FIELDSET> <LEGEND>btnReload_Click</LEGEND> <SPAN style="COLOR: black;font-size: 9pt;font-family:Arial;"><BR><SPAN style="COLOR: blue">private</SPAN> <SPAN style="COLOR: blue">void</SPAN> btnReload_Click(<SPAN style="COLOR: blue">object</SPAN> sender, System.EventArgs e) <BR>{ <BR>&nbsp;&nbsp;&nbsp;&nbsp;Cache.Remove("MyCachedDataSet"); <BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN style="COLOR: green">// Get the DataSet and load it into Cache</SPAN> <BR>&nbsp;&nbsp;&nbsp;&nbsp;DataSet ds = RefreshDataSetFromDB(); <BR>&nbsp;&nbsp;&nbsp;&nbsp;CacheDataSet(ds); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LoadOrdersList(ds); <BR>} <BR></SPAN> </FIELDSET> <P><BR> Now here is where the DataGrid is loaded. The btnGo_Click handler calls the LoadOrderDetailsGrid method, which will grab the Order Details rows that are direct children of the currently selected Order (selected in the droopdown list). </P> <FIELDSET> <LEGEND>btnGo_Click</LEGEND> <SPAN style="COLOR: black;font-size: 9pt;font-family:Arial;"><BR><SPAN style="COLOR: blue">private</SPAN> <SPAN style="COLOR: blue">void</SPAN> btnGo_Click(<SPAN style="COLOR: blue">object</SPAN> sender, System.EventArgs e) <BR>{ <BR>&nbsp;&nbsp;&nbsp;&nbsp;LoadOrderDetailsGrid(); <BR>} <BR></SPAN> </FIELDSET> <P><BR> The method LoadOrderDetailsGrid loads the DataGrid with the approriate related child rows. To do this, it has to take the form of something that can be bound to a DataGrid. In thise case, the code creates a DataView using its overloaded method that accepts the DataTable, the filter criteria and the DataViewRowState. The key here is that the DataView will only contain the single row for the Order that has the selected OrderID. I could have used the Select method to pull out an array of DataRow object, but that does not bind directly to the grid. So instead, I create a DataRowView. The DataRowView is associated with the Orders DataTable's selected row. Next, the DataRowView's CreateChildView method uses the name of the DataRelation (OrdersToOrderDetails) to navigate from the selected Order row and down its children Order Details rows. This result can be bound to a DataGrid. </P> <FIELDSET> <LEGEND>LoadOrderDetailsGrid</LEGEND> <SPAN style="COLOR: black;font-size: 9pt;font-family:Arial;"><BR><SPAN style="COLOR: blue">private void</SPAN> LoadOrderDetailsGrid() <BR>{ <BR>&nbsp;&nbsp;&nbsp;&nbsp;DataSet ds = GetDataSetFromCache(); <BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN style="COLOR: green">// Load the children rows</SPAN> <BR>&nbsp;&nbsp;&nbsp;&nbsp;DataView dv = <SPAN style="COLOR: blue">new</SPAN> DataView(ds.Tables["Orders"], "OrderID = " + ddlOrders.SelectedValue, "", DataViewRowState.CurrentRows); <BR>&nbsp;&nbsp;&nbsp;&nbsp;DataRowView drv = dv[0]; <BR>&nbsp;&nbsp;&nbsp;&nbsp;dgOrderDetails.DataSource = drv.<B> CreateChildView</B>("OrdersToOrderDetails"); <BR>&nbsp;&nbsp;&nbsp;&nbsp;dgOrderDetails.DataBind(); <BR>} <BR></SPAN> </FIELDSET> <BR> This isn't the only way to solve the requirements, of course. But it does handle the caching, ADO.NET and the hierarchical requirements. <BR> </SPAN>

